<template>
  <div class="container">
    <section class="py-0">
      <div class="mb-4  justify-content-between align-items-center text-center">
        <h2>Делегаты, события и лямбды </h2>
      </div>
      <div class="row">
        <div class="card mb-3 shadow-lg p-0 pb-3">
          <div>
            <p><b>Делегаты</b><br /><span>Делегаты представляют такие объекты, которые указывают на методы. То есть делегаты - это указатели на методы и с помощью делегатов мы можем вызвать данные методы.</span><br /><span>Определение делегатов</span><br /><span>Для объявления делегата используется ключевое слово delegate, после которого идет возвращаемый тип, название и параметры. Например:</span><br /><code><span>delegate void Message();</span></code><br /><span>Делегат Message в качестве возвращаемого типа имеет тип void (то есть ничего не возвращает) и не принимает никаких параметров. Это значит, что этот делегат может указывать на любой метод, который не принимает никаких параметров и ничего не возвращает.</span><br /><span>Рассмотрим примение этого делегата:</span><br /><code><span>Message mes; // 2. Создаем переменную делегата</span></code><br /><code><span>mes = Hello; // 3. Присваиваем этой переменной адрес метода</span></code><br /><code><span>mes(); // 4. Вызываем метод</span></code><br /><code><span>void Hello() =&gt; Console.WriteLine("Hello");</span></code><br /><code><span>delegate void Message(); // 1. Объявляем делегат</span></code><br /><span>Место определения делегата</span><br /><span>Если мы определяем делегат в прогаммах верхнего уровня (top-level program), которую по умолчанию представляет файл Program.cs начиная с версии C# 10, как в примере выше, то, как и другие типы, делегат определяется в конце кода. Но в принцие делегат можно определять внутри класса:</span><br /><code><span>class Program</span></code><br /><code><span>{</span></code><br /><code><span>delegate void Message(); // 1. Объявляем делегат</span></code><br /><code><span>static void Main()</span></code><br /><code><span>{</span></code><br /><code><span>Message mes; // 2. Создаем переменную делегата</span></code><br /><code><span>mes = Hello; // 3. Присваиваем этой переменной адрес метода</span></code><br /><code><span>mes(); // 4. Вызываем метод</span></code><br /><code><span>void Hello() =&gt; Console.WriteLine("Hello");</span></code><br /><code><span>}</span></code><br /><code><span>}</span></code><br /><span>Либо вне класса:</span><br /><code><span>delegate void Message(); // 1. Объявляем делегат</span></code><br /><code><span>class Program</span></code><br /><code><span>{</span></code><br /><code><span>static void Main()</span></code><br /><code><span>{</span></code><br /><code><span>Message mes; // 2. Создаем переменную делегата</span></code><br /><code><span>mes = Hello; // 3. Присваиваем этой переменной адрес метода</span></code><br /><code><span>mes(); // 4. Вызываем метод</span></code><br /><code><span>void Hello() =&gt; Console.WriteLine("Hello");</span></code><br /><code><span>}</span></code><br /><code><span>}</span></code><br /><b>Cобытия</b><br /><span>События сигнализируют системе о том, что произошло определенное действие. И если нам надо отследить эти действия, то как раз мы можем применять события.</span><br /><span>Определение и вызов событий</span><br /><span>События объявляются в классе с помощью ключевого слова event, после которого указывается тип делегата, который представляет событие:</span><br /><span>delegate void AccountHandler(string message);</span><br /><span>event AccountHandler Notify;</span><br /><span>В данном случае вначале определяется делегат AccountHandler, который принимает один параметр типа string. Затем с помощью ключевого слова event определяется событие с именем Notify, которое представляет делегат AccountHandler. Название для события может быть произвольным, но в любом случае оно должно представлять некоторый делегат.</span><br /><span>Определив событие, мы можем его вызвать в программе как метод, используя имя события:</span><br /><code><span>Notify("Произошло действие");</span></code><br /><span>Поскольку событие Notify представляет делегат AccountHandler, который принимает один параметр типа string - строку, то при вызове события нам надо передать в него строку.</span><br /><span>Однако при вызове событий мы можем столкнуться с тем, что событие равно null в случае, если для его не определен обработчик. Поэтому при вызове события лучше его всегда проверять на null. Например, так:</span><br /><code><span>if(Notify !=null) Notify("Произошло действие");</span></code><br /><span>Или так:</span><br /><code><span>Notify?.Invoke("Произошло действие");</span></code><br /><span>В этом случае поскольку событие представляет делегат, то мы можем его вызвать с помощью метода Invoke(), передав в него необходимые значения для параметров.</span><br /><code><span>class Account</span></code><br /><code><span>{</span></code><br /><code><span>public delegate void AccountHandler(string message);</span></code><br /><span><code>public event AccountHandler? Notify; //</code> 1.Определение события</span><br /><code><span>public Account(int sum) =&gt; Sum = sum;</span></code><br /><code><span>public int Sum { get; private set; }</span></code><br /><code><span>public void Put(int sum)</span></code><br /><code><span>{</span></code><br /><code><span>Sum += sum;</span></code><br /><span><code>Notify?.Invoke($"На счет поступило: {sum}"); //</code> 2.Вызов события</span><br /><code><span>}</span></code><br /><code><span>public void Take(int sum)</span></code><br /><code><span>{</span></code><br /><code><span>if (Sum &gt;= sum)</span></code><br /><code><span>{</span></code><br /><code><span>Sum -= sum;</span></code><br /><code><span>Notify?.Invoke($"Со счета снято: {sum}"); // 2.Вызов события</span></code><br /><code><span>}</span></code><br /><code><span>else</span></code><br /><code><span>{ Notify?.Invoke($"Недостаточно денег на счете. Текущий баланс: {Sum}"); ; } } }</span></code><br /><span>Теперь с помощью события Notify мы уведомляем систему о том, что были добавлены средства и о том, что средства сняты со счета или на счете недостаточно средств.</span><br /><span>Добавление обработчика события</span><br /><span>С событием может быть связан один или несколько обработчиков. Обработчики событий - это именно то, что выполняется при вызове событий. Нередко в качестве обработчиков событий применяются методы. Каждый обработчик событий по списку параметров и возвращаемому типу должен соответствовать делегату, который представляет событие. Для добавления обработчика события применяется операция +=:</span><br /><span>Notify += обработчик события;</span><br /><span>Определим обработчики для события Notify, чтобы получить в программе нужные уведомления:</span><br /><code><span>Account account = new Account(100);</span></code><br /><code><span>account.Notify += DisplayMessage; // Добавляем обработчик для события Notify</span></code><br /><code><span>account.Put(20); // добавляем на счет 20</span></code><br /><code><span>Console.WriteLine($"Сумма на счете: {account.Sum}");</span></code><br /><code><span>account.Take(70); // пытаемся снять со счета 70</span></code><br /><code><span>Console.WriteLine($"Сумма на счете: {account.Sum}");</span></code><br /><code><span>account.Take(180); // пытаемся снять со счета 180</span></code><br /><code><span>Console.WriteLine($"Сумма на счете: {account.Sum}");</span></code><br /><code><span>void DisplayMessage(string message) =&gt; Console.WriteLine(message);</span></code><br /><span>В данном случае в качестве обработчика используется метод DisplayMessage, который соответствует по списку параметров и возвращаемому типу делегату AccountHandler. В итоге при вызове события Notify?.Invoke() будет вызываться метод DisplayMessage, которому для параметра message будет передаваться строка, которая передается в Notify?.Invoke(). В DisplayMessage просто выводим полученное от события сообщение, но можно было бы определить любую логику.</span><br /><span>Если бы в данном случае обработчик не был бы установлен, то при вызове события Notify?.Invoke() ничего не происходило, так как событие Notify было бы равно null.</span><br /><span>Теперь мы можем выделить класс Account в отдельную библиотеку классов и добавлять в любой проект.</span></p>
            <p><b>Лямбды</b><br /><span>Лямбда-выражения представляют упрощенную запись анонимных методов. Лямбда-выражения позволяют создать емкие лаконичные методы, которые могут возвращать некоторое значение и которые можно передать в качестве параметров в другие методы.</span><br /><span>Ламбда-выражения имеют следующий синтаксис: слева от лямбда-оператора =&gt; определяется список параметров, а справа блок выражений, использующий эти параметры:</span><br /><span>(список_параметров) =&gt; выражение</span><br /><span>С точки зрения типа данных лямбда-выражение представляет делегат. Например, определим простейшее лямбда-выражение:</span><br /><code><span>Message hello = () =&gt; Console.WriteLine("Hello");</span></code><br /><code><span>hello(); // Hello</span></code><br /><code><span>hello(); // Hello</span></code><br /><code><span>hello(); // Hello</span></code><br /><code><span>delegate void Message();</span></code><br /><span>В данном случае переменная hello представляет делегат Message - то есть некоторое действие, которое ничего не возвращает и не принимает никаких параметров. В качестве значения этой переменной присваивается лямбда-выражение. Это лямбда-выражение должно соответствовать делегату Message - оно тоже не принимает никаких параметров, поэтому слева от лямбда-оператора идут пустые скобки. А справа от лямбда-оператора идет выполняемое выражение - Console.WriteLine("Hello")</span><br /><span>Затем в программе можно вызывать эту переменную как метод.</span><br /><span>Если лямбда-выражение содержит несколько действий, то они помещаются в фигурные скобки:</span><br /><code><span>Message hello = () =&gt;</span></code><br /><code><span>{</span></code><br /><code><span>Console.Write("Hello ");</span></code><br /><code><span>Console.WriteLine("World");</span></code><br /><code><span>};</span></code><br /><code><span>hello(); // Hello World</span></code><br /><span>Выше мы определили переменную hello, которая представляет делегат Message. Но начиная с версии C# 10 мы можем применять неявную типизацию (определение переменной с помощью оператора var) при определении лямбда-выражения:</span><br /><code><span>var hello = () =&gt; Console.WriteLine("Hello");</span></code><br /><code><span>hello(); // Hello</span></code><br /><code><span>hello(); // Hello</span></code><br /><code><span>hello(); // Hello</span></code><br /><span>Но какой тип в данном случае представляет переменная hello? При неявной типизации компилятор сам пытается сопоставить лямбда-выражение на основе его опеределения с каким-нибудь делегатом. Например, выше определенное лямбда-выражение hello по умолчанию компилятор будет рассматривать как переменную встроенного делегата Action, который не принимает никаких параметров и ничего не возвращает.</span><br /><span>Параметры лямбды</span><br /><span>При определении списка параметров мы можем не указывать для них тип данных:</span><br /><code><span>Operation sum = (x, y) =&gt; Console.WriteLine($"{x} + {y} = {x + y}");</span></code><br /><code><span>sum(1, 2); // 1 + 2 = 3</span></code><br /><code><span>sum(22, 14); // 22 + 14 = 36</span></code><br /><code><span>delegate void Operation(int x, int y);</span></code><br /><span>В данном случае компилятор видит, что лямбда-выражение sum представляет тип Operation, а значит оба параметра лямбды представляют тип int. Поэтому никак проблем не возникнет.</span><br /><span>Однако если мы применяем неявную типизацию, то у компилятора могут возникнуть трудности, чтобы вывести тип делегата для лямбда-выражения, например, в следующем случае</span><br /><code><span>var sum = (x, y) =&gt; Console.WriteLine($"{x} + {y} = {x + y}"); // ! Ошибка</span></code><br /><span>В этом случае можно указать тип параметров</span><br /><code><span>var sum = (int x, int y) =&gt; Console.WriteLine($"{x} + {y} = {x + y}");</span></code><br /><code><span>sum(1, 2); // 1 + 2 = 3</span></code><br /><code><span>sum(22, 14); // 22 + 14 = 36</span></code><br /><span>Если лямбда имеет один параметр, для которого не требуется указывать тип данных, то скобки можно опустить:</span><br /><code><span>PrintHandler print = message =&gt; Console.WriteLine(message);</span></code><br /><code><span>print("Hello"); // Hello</span></code><br /><code><span>print("Welcome"); // Welcome</span></code><br /><code><span>delegate void PrintHandler(string message);</span></code><br /><b>Делегаты, события и лямбды закончились</b></p>

          </div>
        </div>
      </div>
    </section>
    <nav class="container text-center">
      <router-link @click="scrollToTop()" to="/basicofprogramming"><button type="button" class="btn btn-primary">Основы программирования на C#</button></router-link>
      <router-link @click="scrollToTop()" to="/classstructures"><button type="button" class="btn btn-primary">Классы, структуры и пространства имён</button></router-link>
      <router-link @click="scrollToTop()" to="/objectorientedprogramming"><button type="button" class="btn btn-primary">ООП</button></router-link>
      <router-link @click="scrollToTop()" to="/exceptionhandling"><button type="button" class="btn btn-primary">Обработка исключений</button><br><br></router-link>
      <router-link @click="scrollToTop()" to="/delegate"><button type="button" class="btn btn-primary">Делегаты, события и лямбды</button></router-link>
      <router-link @click="scrollToTop()" to="/interfacee"><button type="button" class="btn btn-primary">Интерфейсы</button></router-link>
      <router-link @click="scrollToTop()" to="/dopioop"><button type="button" class="btn btn-primary">Дополнительны возможности ООП в C#</button><br><br></router-link>
      <router-link @click="scrollToTop()" to="/programmingigr"><button type="button" class="btn btn-primary justify-content-center">Программирование игр</button></router-link>
    </nav>
  </div>
</template>

<script>
export default {
  name: "delegate",

  methods: {
    scrollToTop() {
      window.scrollTo(0, 0);
    },
  }
}
</script>

<style scoped>
p{
  font-size: 14px;
  text-indent: 25px;
}
</style>