<template>
  <div class="container">
    <section class="py-0">
      <div class="mb-4  justify-content-between align-items-center text-center">
        <h2>Объектно-ориентированное программирование </h2>
      </div>
      <div class="row">
        <div class="card mb-3 shadow-lg p-0 pb-3">
          <div>
            <p><b>Наследование</b><br /><span>Наследование (inheritance) является одним из ключевых моментов ООП. Благодаря наследованию один класс может унаследовать функциональность другого класса.</span><br /><span>Пусть у нас есть следующий класс Person, который описывает отдельного человека:</span><br /><code><span>class Person</span></code><br /><code><span>{ private string _name = "";</span></code><br /><code><span>public string Name</span></code><br /><code><span>{ get { return _name; }</span></code><br /><code><span>set { _name = value; } }</span></code><br /><code><span>public void Print()</span></code><br /><code><span>{ Console.WriteLine(Name); }</span><span>}</span></code><br /><span>Но вдруг нам потребовался класс, описывающий сотрудника предприятия - класс Employee. Поскольку этот класс будет реализовывать тот же функционал, что и класс Person, так как сотрудник - это также и человек, то было бы рационально сделать класс Employee производным (или наследником, или подклассом) от класса Person, который, в свою очередь, называется базовым классом или родителем (или суперклассом):</span><br /><code><span>class Employee : Person</span><span>{ }</span></code><br /><span>После двоеточия мы указываем базовый класс для данного класса. Для класса Employee базовым является Person, и поэтому класс Employee наследует все те же свойства, методы, поля, которые есть в классе Person. Единственное, что не передается при наследовании, это конструкторы базового класса с параметрами.</span><br /><span>Таким образом, наследование реализует отношение is-a (является), объект класса Employee также является объектом класса Person:</span><br /><code><span>Person person = new Person { Name = "Tom" };</span></code><br /><code><span>person.Print(); // Tom</span></code><br /><code><span>person = new Employee { Name = "Sam" };</span></code><br /><code><span>person.Print(); // Sam</span></code><br /><span>И поскольку объект Employee является также и объектом Person, то мы можем так определить переменную: Person p = new Employee().</span><br /><span>По умолчанию все классы наследуются от базового класса Object, даже если мы явным образом не устанавливаем наследование. Поэтому выше определенные классы Person и Employee кроме своих собственных методов, также будут иметь и методы класса <code>Object: ToString(), Equals(), GetHashCode() и GetType().</code></span><br /><span>Все классы по умолчанию могут наследоваться. Однако здесь есть ряд ограничений:</span></p>
            <ul>
              <li>Не поддерживается множественное наследование, класс может наследоваться только от одного класса.</li>
              <li>При создании производного класса надо учитывать тип доступа к базовому классу - тип доступа к производному классу должен быть таким же, как и у базового класса, или более строгим. То есть, если базовый класс у нас имеет тип доступа internal, то производный класс может иметь тип доступа internal или private, но не public.</li>
              <li>Если класс объявлен с модификатором sealed, то от этого класса нельзя наследовать и создавать производные классы. Например, следующий класс не допускает создание наследников:<br />sealed class Admin{ }</li>
              <li>Нельзя унаследовать класс от статического класса.</li>
            </ul>
            <p><span>Доступ к членам базового класса из класса-наследника</span><br /><span>Вернемся к нашим классам Person и Employee. Хотя Employee наследует весь функционал от класса Person, посмотрим, что будет в следующем случае:</span><br /><code><span>class Employee : Person</span><span>{</span></code><br /><code><span>public void PrintName()</span></code><br /><code><span>{ Console.WriteLine(_name); }</span><span>}</span></code><br /><span>Этот код не сработает и выдаст ошибку, так как переменная _name объявлена с модификатором private и поэтому к ней доступ имеет только класс Person. Но зато в классе Person определено общедоступное свойство Name, которое мы можем использовать, поэтому следующий код у нас будет работать нормально:</span><br /><code><span>class Employee : Person</span><span>{</span></code><br /><code><span>public void PrintName()</span></code><br /><code><span>{ Console.WriteLine(Name); }</span><span>}</span></code><br /><span>Таким образом, производный класс может иметь доступ только к тем членам базового класса, которые определены с модификаторами private protected (если базовый и производный класс находятся в одной сборке), public, internal (если базовый и производный класс находятся в одной сборке), protected и protected internal.</span></p>
            <p><b>Виртуальные методы и свойства</b><br /><span>При наследовании нередко возникает необходимость изменить в классе-наследнике функционал метода, который был унаследован от базового класса. В этом случае класс-наследник может переопределять методы и свойства базового класса.</span><br /><span>Те методы и свойства, которые мы хотим сделать доступными для переопределения, в базовом классе помечается модификатором virtual. Такие методы и свойства называют виртуальными.</span><br /><span>А чтобы переопределить метод в классе-наследнике, этот метод определяется с модификатором override. Переопределенный метод в классе-наследнике должен иметь тот же набор параметров, что и виртуальный метод в базовом классе.</span><br /><span>Например, рассмотрим следующие классы:</span><br /><code><span>class Person</span></code><br /><code><span>{</span></code><br /><code><span>public string Name { get; set; }</span></code><br /><code><span>public Person(string name)</span></code><br /><code><span>{ Name = name; }</span></code><br /><code><span>public virtual void Print()</span></code><br /><code><span>{ Console.WriteLine(Name); }</span></code><br /><code><span>}</span></code><br /><code><span>class Employee : Person</span></code><br /><code><span>{</span></code><br /><code><span>public string Company { get; set; }</span></code><br /><code><span>public Employee(string name, string company) : base(name)</span></code><br /><code><span>{ Company = company; }</span></code><br /><code><span>}</span></code><br /><span>Здесь класс Person представляет человека. Класс Employee наследуется от Person и представляет сотруднника предприятия. Этот класс кроме унаследованного свойства Name имеет еще одно свойство - Company.</span><br /><span>Чтобы сделать метод Print доступным для переопределения, этот метод определен с модификатором virtual. Поэтому мы можем переопределить этот метод, но можем и не переопределять. Допустим, нас устраивает реализация метода из базового класса. В этом случае объекты Employee будут использовать реализацию метода Print из класса Person:</span><br /><code><span>Person bob = new Person("Bob");</span></code><br /><code><span>bob.Print(); // вызов метода Print из класса Person</span></code><br /><code><span>Employee tom = new Employee("Tom", "Microsoft");</span></code><br /><code><span>tom.Print(); // вызов метода Print из класса Person</span></code><br /><span>Консольный вывод:</span><br /><code><span>Bob</span></code><br /><code><span>Tom</span></code><br /><span>Но также можем переопределить виртуальный метод. Для этого в классе-наследнике определяется метод с модификатором override, который имеет то же самое имя и набор параметров:</span><br /><code><span>class Employee : Person</span></code><br /><code><span>{</span></code><br /><code><span>public string Company { get; set; }</span></code><br /><code><span>public Employee(string name, string company)</span></code><br /><code><span>: base(name)</span></code><br /><code><span>{ Company = company; }</span></code><br /><code><span>public override void Print()</span></code><br /><code><span>{ Console.WriteLine($"{Name} работает в {Company}"); }</span></code><br /><code><span>}</span></code><br /><span>Возьмем те же самые объекты:</span><br /><code><span>Person bob = new Person("Bob");</span></code><br /><code><span>bob.Print(); // вызов метода Print из класса Person</span></code><br /><code><span>Employee tom = new Employee("Tom", "Microsoft");</span></code><br /><code><span>tom.Print(); // вызов метода Print из класса Employee</span></code><br /><span>Консольный вывод:</span><br /><code><span>Bob</span></code><br /><code><span>Tom работает в Microsoft</span></code><br /><span>Виртуальные методы базового класса определяют интерфейс всей иерархии, то есть в любом производном классе, который не является прямым наследником от базового класса, можно переопределить виртуальные методы. Например, мы можем определить класс Manager, который будет производным от Employee, и в нем также переопределить метод Print.</span><br /><span>При переопределении виртуальных методов следует учитывать ряд ограничений:</span><br /><span>Виртуальный и переопределенный методы должны иметь один и тот же модификатор доступа. То есть если виртуальный метод определен с помощью модификатора public, то и переопредленный метод также должен иметь модификатор public.</span><br /><span>Нельзя переопределить или объявить виртуальным статический метод.&nbsp;</span></p>

            <p><b>Абстрактные классы и члены классов</b><br /><span>Абстрактные классы</span><br /><span>Кроме обычных классов в C# есть абстрактные классы. Зачем они нужны? Классы обычно представляют некий план определенного рода объектов или сущностей. Например, мы можем определить класс Car для преставления машин или класс Person для представления людей, вложив в эти классы соответствующие свойства, поля, методы, которые будут описывать данные объекты. Однако некоторые сущности, которые мы хотим выразить с помощью языка программирования, могут не иметь конкретного воплощения. Например, в реальности не существует геометрической фигуры как таковой. Есть круг, прямоугольник, квадрат, но просто фигуры нет. Однако же и круг, и прямоугольник имеют что-то общее и являются фигурами. И для описания подобных сущностей, которые не имеют конкретного воплощения, предназначены абстрактные классы.</span><br /><span>Абстрактный класс похож на обычный класс. Он также может иметь переменные, методы, конструкторы, свойства. Единственное, что при определении абстрактных классов используется ключевое слово abstract. Например, определим абстрактный класс, который представляет некое транспортное средство:</span><br /><code><span>abstract class Transport</span></code><br /><code><span>{</span></code><br /><code><span>public void Move()</span></code><br /><code><span>{ Console.WriteLine("Транспортно средство движется"); }</span></code><br /><code><span>}</span></code><br /><span>Транспортное средство представляет некоторую абстракцию, которая не имеет конкретного воплощения. То есть есть легковые и грузовые машины, самолеты, морские судна, кто-то на космическом корабле любит покататься, но как такового транспортного средства нет. Тем не менее все транспортные средства имеют нечто общее - они могут перемещаться. И для этого в классе определен метод Move, который эмулирует перемещение.</span><br /><span>Но главное отличие абстрактных классов от обычных состоит в том, что мы НЕ можем использовать конструктор абстрактного класса для создания экземпляра класса. Например, следующим образом:</span><br /><code><span>Transport tesla = new Transport();</span></code><br /><span>Тем не менее абстрактные классы полезны для описания некоторого общего функционала, который могут наследовать и использовать производные классы.</span><br /><span>Абстрактные члены классов</span><br /><span>Кроме обычных свойств и методов абстрактный класс может иметь абстрактные члены классов, которые определяются с помощью ключевого слова abstract и не имеют никакого функционала. В частности, абстрактными могут быть:</span></p>
            <ul>
              <li>Методы</li>
              <li>Свойства</li>
              <li>Индексаторы</li>
              <li>События</li>
            </ul>
            <p><span>Абстрактные члены классов не должны иметь модификатор private. При этом производный класс обязан переопределить и реализовать все абстрактные методы и свойства, которые имеются в базовом абстрактном классе. При переопределении в производном классе такой метод или свойство также объявляются с модификатором override (как и при обычном переопределении виртуальных методов и свойств). Также следует учесть, что если класс имеет хотя бы одный абстрактный метод (или абстрактные свойство, индексатор, событие), то этот класс должен быть определен как абстрактный.</span><br /><span>Абстрактные члены также, как и виртуальные, являются частью полиморфного интерфейса. Но если в случае с виртуальными методами мы говорим, что класс-наследник наследует реализацию, то в случае с абстрактными методами наследуется интерфейс, представленный этими абстрактными методами.</span><br /><b>ООП закончилось</b></p>
          </div>
        </div>
      </div>
    </section>

  </div>
  <nav class="container text-center">
    <router-link @click="scrollToTop()" to="/basicofprogramming"><button type="button" class="btn btn-primary">Основы программирования на C#</button></router-link>
    <router-link @click="scrollToTop()" to="/classstructures"><button type="button" class="btn btn-primary">Классы, структуры и пространства имён</button></router-link>
    <router-link @click="scrollToTop()" to="/objectorientedprogramming"><button type="button" class="btn btn-primary">ООП</button></router-link>
    <router-link @click="scrollToTop()" to="/exceptionhandling"><button type="button" class="btn btn-primary">Обработка исключений</button><br><br></router-link>
    <router-link @click="scrollToTop()" to="/delegate"><button type="button" class="btn btn-primary">Делегаты, события и лямбды</button></router-link>
    <router-link @click="scrollToTop()" to="/interfacee"><button type="button" class="btn btn-primary">Интерфейсы</button></router-link>
    <router-link @click="scrollToTop()" to="/dopioop"><button type="button" class="btn btn-primary">Дополнительны возможности ООП в C#</button><br><br></router-link>
    <router-link @click="scrollToTop()" to="/programmingigr"><button type="button" class="btn btn-primary justify-content-center">Программирование игр</button></router-link>
  </nav>
</template>

<script>
export default {
  name: "objectorientedprogramming",

  methods: {
    scrollToTop() {
      window.scrollTo(0, 0);
    },
  }
}
</script>

<style scoped>
p{
  font-size: 16px;
}

</style>