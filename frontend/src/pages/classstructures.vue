<template>
  <div class="container">
    <section class="py-0">
      <div class="mb-4  justify-content-between align-items-center text-center">
        <h2>Классы, структуры и пространства имён </h2>
      </div>
      <div class="row">
        <div class="card mb-3 shadow-lg p-0 pb-3">
          <div>
            <p class="block1"><b>Классы и объекты</b><br /><span>C# является полноценным объектно-ориентированным языком. Это значит, что программу на C# можно представить в виде взаимосвязанных взаимодействующих между собой объектов.</span><br /><span>Описанием объекта является класс, а объект представляет экземпляр этого класса. Можно еще провести следующую аналогию. У нас у всех есть некоторое представление о человеке, у которого есть имя, возраст, какие-то другие характеристики. То есть некоторый шаблон - этот шаблон можно назвать классом. Конкретное воплощение этого шаблона может отличаться, например, одни люди имеют одно имя, другие - другое имя. И реально существующий человек (фактически экземпляр данного класса) будет представлять объект этого класса.</span><br /><span>В принципе ранее уже использовались классы. Например, тип string, который представляет строку, фактически является классом. Или, например, класс Console, у которого метод WriteLine() выводит на консоль некоторую информацию. Теперь же посмотрим, как мы можем определять свои собственные классы.</span><br /><span>По сути класс представляет новый тип, который определяется пользователем. Класс определяется с помощью ключевого слова сlass:</span><br /><code><span>class название_класса</span></code><br /><code><span>{ // содержимое класса }</span></code><br /><span>После слова class идет имя класса и далее в фигурных скобках идет собственно содержимое класса. Например, определим в файле Program.cs класс Person, который будет представлять человека:</span><br /><code><span>class Person</span></code><code><span>{ }</span></code><br /><span>Однако такой класс не особо показателен, поэтому добавим в него некоторую функциональность.</span><br /><span>Поля и методы класса</span><br /><span>Класс может хранить некоторые данные. Для хранения данных в классе применяются поля. По сути поля класса - это переменные, определенные на уровне класса.</span><br /><span>Кроме того, класс может определять некоторое поведение или выполняемые действия. Для определения поведения в классе применяются методы.</span><br /><span>Итак, добавим в класс Person поля и методы:</span><br /><code><span>class Person {</span></code><br /><code><span>public string name = "Undefined"; // имя</span></code><br /><code><span>public int age; // возраст</span></code><br /><code><span>public void Print()</span></code><br /><code><span>{ Console.WriteLine($"Имя: {name} Возраст: {age}"); }</span><span>}</span></code><br /><span>В данном случае в классе Person определено поле name, которое хранит имя, и поле age, которое хранит возраст человека. В отличие от переменных, определенных в методах, поля класса могут иметь модификаторы, которые указываются перед полем. Так, в данном случае, чтобы все поля были доступны вне класса Person поля определены с модификатором public.</span><br /><span>При определении полей мы можем присвоить им некоторые значения, как в примере выше в случае переменной name. Если поля класса не инициализированы, то они получают значения по умолчанию. Для переменных числовых типов это число 0.</span><br /><span>Также в классе Person определен метод <code>Print()</code>. Методы класса имеют доступ к его поля, и в данном случае обращаемся к полям класса name и age для вывода их значения на консоль. И чтобы этот метод был виден вне класса, он также определен с модификатором public.</span><br /><span>Создание объекта класса</span><br /><span>После определения класса мы можем создавать его объекты. Для создания объекта применяются конструкторы. По сути конструкторы представляют специальные методы, которые называются так же как и класс, и которые вызываются при создании нового объекта класса и выполняют инициализацию объекта. Общий синтаксис вызова конструктора:</span><br /><span>new конструктор_класса(параметры_конструктора);</span><br /><span>Сначала идет оператор new, который выделяет память для объекта, а после него идет вызов конструктора.</span><br /><span>Конструктор по умолчанию</span><br /><span>Если в классе не определено ни одного конструктора (как в случае с нашим классом Person), то для этого класса автоматически создается пустой конструктор по умолчанию, который не принимает никаких параметров.</span><br /><span>Теперь создадим объект класса Person:</span><br /><code><span>Person tom = new Person(); // создание объекта класса Person</span></code><br /><code><span>// определение класса Person</span></code><br /><code><span>class Person</span></code><br /><code><span>{ public string name = "Undefined";</span></code><br /><code><span>public int age;</span></code><br /><code><span>public void Print()</span></code><br /><code><span>{ Console.WriteLine($"Имя: {name} Возраст: {age}"); }</span><span>}</span></code></p>
            <p class="block1"><b>Конструкторы, инициализаторы и деконструкторы</b><br /><span>Создание конструкторов</span><br /><span>На уровне кода конструктор представляет метод, который называется по имени класса, который может иметь параметры, но для него не надо определять возвращаемый тип. Например, определим в классе Person простейший конструктор:</span><br /><code><span>Person tom = new Person(); // Создание объекта класса Person</span></code><br /><code><span>tom.Print(); // Имя: Tom Возраст: 37</span></code><br /><code><span>class Person</span></code><br /><code><span>{ public string name;</span></code><br /><code><span>public int age;</span></code><br /><code><span>public Person()</span></code><br /><code><span>{ Console.WriteLine("Создание объекта Person");</span></code><br /><code><span>name = "Tom";</span></code><br /><code><span>age = 37; }</span></code><br /><code><span>public void Print()</span></code><br /><code><span>{ Console.WriteLine($"Имя: {name} Возраст: {age}"); }</span><span>}</span></code><br /><span>Итак, здесь определен конструктор, который выводит на консоль некоторое сообщение и инициализирует поля класса.</span><br /><code><span>public Person()</span></code><br /><code><span>{ Console.WriteLine("Создание объекта Person");</span></code><br /><code><span>name = "Tom";</span></code><br /><code><span>age = 37; }</span></code><br /><span>Конструкторы могут иметь модификаторы, которые указываются перед именем конструктора. Так, в данном случае, чтобы конструктор был доступен вне класса Person, он определен с модификатором <code>public</code>.</span><br /><span>Определив конструктор, мы можем вызвать его для создания объекта <code>Person</code>:</span><br /><code><span>Person tom = new Person(); // Создание объекта Person</span></code><br /><span>В данном случае выражение <code>Person()</code> как раз представляет вызов определенного в классе конструктора (это больше не автоматический конструктор по умолчанию, которого у класса теперь нет). Соответственно при его выполнении на консоли будет выводиться строка "Создание объекта Person"</span><br /><span>Подобным образом мы можем определять и другие конструкторы в классе.</span><br /><span>Ключевое слово this</span><br /><span>Ключевое слово this представляет ссылку на текущий экземпляр/объект класса.</span><br /><code><span>this.name = name;</span></code><br /><span>первая часть - this.name означает, что name - это поле текущего класса, а не название параметра name. Если бы у нас параметры и поля назывались по-разному, то использовать слово this было бы необязательно. Также через ключевое слово this можно обращаться к любому полю или методу.</span><br /><span>Инициализаторы объектов</span><br /><span>Для инициализации объектов классов можно применять инициализаторы. Инициализаторы представляют передачу в фигурных скобках значений доступным полям и свойствам объекта:</span><br /><code><span>Person tom = new Person { name = "Tom", age = 31 };</span></code><br /><code><span>// или так</span></code><br /><code><span>// Person tom = new() { name = "Tom", age = 31 };</span></code><br /><code><span>tom.Print(); // Имя: Tom Возраст: 31</span></code><br /><span>С помощью инициализатора объектов можно присваивать значения всем доступным полям и свойствам объекта в момент создания. При использовании инициализаторов следует учитывать следующие моменты:</span><br /><span>С помощью инициализатора мы можем установить значения только доступных из вне класса полей и свойств объекта. Например, в примере выше поля name и age имеют модификатор доступа public, поэтому они доступны из любой части программы.</span><br /><span>Инициализатор выполняется после конструктора, поэтому если и в конструкторе, и в инициализаторе устанавливаются значения одних и тех же полей и свойств, то значения, устанавливаемые в конструкторе, заменяются значениями из инициализатора.</span><br /><span>Инициализаторы удобно применять, когда поле или свойство класса представляет другой класс.</span><br /><span>Деконструкторы</span><br /><span>Деконструкторы (не путать с деструкторами) позволяют выполнить декомпозицию объекта на отдельные части.</span><br /><span>Например, пусть у нас есть следующий класс Person:</span><br /><code><span>class Person</span></code><br /><code><span>{ string name;</span></code><br /><code><span>int age;</span></code><br /><code><span>public Person(string name, int age)</span></code><br /><code><span>{ this.name = name;</span></code><br /><code><span>this.age = age; }</span></code><br /><code><span>public void Deconstruct(out string personName, out int personAge)</span></code><br /><code><span>{ personName = name;</span></code><br /><code><span>personAge = age; }</span><span>}</span></code><br /><span>В этом случае мы могли бы выполнить декомпозицию объекта <code>Person</code> так:</span><br /><code><span>Person person = new Person("Tom", 33);</span></code><br /><code><span>(string name, int age) = person;</span></code><br /><code><span>Console.WriteLine(name); // Tom</span></code><br /><code><span>Console.WriteLine(age); // 33</span></code><br /><span>Значения переменным из деконструктора передаюся по позиции. То есть первое возвращаемое значение в виде параметра personName передается первой переменной - name, второе возващаемое значение - переменной age.</span><br /><span>По сути деконструкторы это не более,чем синтаксический сахар. Это все равно, что если бы мы написали:</span><br /><code><span>Person person = new Person("Tom", 33);</span></code><br /><code><span>string name; int age;</span></code><br /><code><span>person.Deconstruct(out name, out age);</span></code><br /><span>При получении значений из декоструктора нам необходимо предоставить столько переменных, сколько деконструктор возвращает значений. Однако бывает, что не все эти значения нужны. И вместо возвращаемых значений мы можем использовать прочерк _. Например, нам надо получить только возраст пользователя:</span><br /><code><span>Person person = new Person("Tom", 33);</span></code><br /><code><span>(_, int age) = person;</span></code><br /><code><span>Console.WriteLine(age); // 33</span></code><br /><span>Поскольку первое возвращаемое значение - это имя пользователя, которое не нужно, в в данном случае вместо переменной прочерк.</span></p>
            <p class="block1"><b>Класс Program и метод Main. Программы верхнего уровня</b><br /><span>Точкой входа в программу на языке C# является метод Main. Именно с этого метода начинается выполнение программы на C#. И программа на C# должна обязательно иметь метод Main. Однако может возникнуть вопрос, какой еще метод Main, если, например, Visual Studio 2022 по умолчанию создает проект консольного приложения со следующим кодом:</span><br /><code><span>Console.WriteLine("Hello, World!");</span></code><br /><span>И эта программа никаких методов Main не содержит, но при этом нормально выполняется и выводит на консоль строку "Hello, World!", как и запланировано. Это так называемая программа верхнего уровня (top-level program). А вызов <code>Console.WriteLine("Hello, World!")</code> представляет инструкцию вехнего уровня (top-level statement)</span><br /><span>Однако в реальности этот код неявно помещается компилятором в метод Main, который, в свою очередь, помещается в класс Program. В действительности название класса может быть любым (как правило, это класс Program, собственно поэтому генерируемый по умолчанию файл кода называется Program.cs). Но метод Main является обязательной частью консольного приложения. Поэтому выше представленный код фактически эквивалентен следующей программе:</span><br /><code><span>class Program</span></code><br /><code><span>{ static void Main(string[] args)</span></code><br /><code><span>{ Console.WriteLine("Hello, World!"); }</span><span>}</span></code><br /><span>Определение метода Main обязательно начинается с модификатора static, которое указывает, что метод Main - статический. Позже мы подробнее разберем, что все это значит.</span><br /><span>Возвращаемым типом метода Main обязательно является тип <code>void</code>. Кроме того, в качестве параметра он принимает массив строк - <code>string[]</code> <code>args</code> - в реальной программе это те параметры, через которые при запуске программы из консоли мы можем передать ей некоторые значения. Внутри метода располагаются действия, которые выполняет программа.</span>&nbsp;</p>
            <p class="block1"><b>Структуры</b><br /><span>Наряду с классами структуры представляют еще один способ создания собственных типов данных в C#. Более того многие примитивные типы, например, int, double и т.д., по сути являются структурами.</span><br /><span>Определение структуры</span><br /><span>Для определения структуры применяется ключевое слово struct:</span><br /><code><span>struct имя_структуры { // элементы структуры }</span></code><br /><span>После слова struct идет название структуры и далее в фигурных скобках размещаются элементы структуры - поля, методы и т.д.</span><br /><span>Например, определим структуру, которая будет называться Person и которая будет представлять человека:</span><br /><code><span>struct Person</span><span>{ }</span></code><br /><span>Как и классы, структуры могут хранить состояние в виде полей (переменных) и определять поведение в виде методов. Например, добавим в структуру Person пару полей и метод:</span><br /><code><span>struct Person</span></code><br /><code><span>{ public string name;</span></code><br /><code><span>public int age;</span></code><br /><code><span>public void Print()</span></code><br /><code><span>{ Console.WriteLine($"Имя: {name} Возраст: {age}"); }</span><span>}</span></code><br /><span>В данном случае определены две переменные - name и age для хранения соответственно имени и возраста человека и метод Print для вывода информации о человеке на консоль.</span><br /><span>И как и в случае с классами, для обращения к функциональности структуры - полям, методам и другим компонентам структуры применяется точечная нотация - после объекта структуры ставится точка, а затем указывается компонент структуры:</span><br /><code><span>объект.поле_структуры</span></code><br /><code><span>объект.метод_структуры(параметры_метода)</span></code><br /><b>Пространства имен</b><br /><span>Обычно определяемые классы и другие типы в .NET не существуют сами по себе, а заключаются в специальные контейнеры - пространства имен. Пространства имен позволяют организовать код программы в логические блоки, поволяют объединить и отделить от остального кода некоторую функциональность, которая связана некоторой общей идеей или которая выполняет определенную задачу.</span><br /><span>Для определения пространства имен применяется ключевое слово namespace, после которого идет название название пространства имен:</span><br /><code><span>namespace имя_пространства_имен</span></code><br /><code><span>{ // содержимое пространства имен }</span></code><br /><span>Например, определим в файле Program.cs пространство имен, которое будет называться Base</span><br /><code><span>namespace Base</span><span>{</span></code><br /><code><span>class Person</span></code><br /><code><span>{ string name;</span></code><br /><code><span>public Person(string name) =&gt; this.name = name;</span></code><br /><code><span>public void Print() =&gt; Console.WriteLine($"Имя: {name}"); }</span><span>}</span></code><br /><span>Здесь пространство имен содержит класс Person, которой имеет одну переменную - name, конструктор и метод Print.</span><br /><span>Подключение пространства имен</span><br /><span>Однако полное имя класса с учетом пространства имен добавляет в код избыточность - особенно, если пространство имен содержит множество классов, которые мы хотим использовать. И чтобы не писать полное имя класса, мы можем просто подключить пространство имен с помощью директивы using:</span><br /><code><span>using Base; // подключение пространства имен Base</span></code><br /><code><span>Person tom = new("Tom");</span></code><br /><code><span>tom.Print(); // Имя: Tom</span></code><br /><code><span>namespace Base</span></code><br /><code><span>{ class Person</span></code><br /><code><span>{</span></code><br /><code><span>string name;</span></code><br /><code><span>public Person(string name) =&gt; this.name = name;</span></code><br /><code><span>public void Print() =&gt; Console.WriteLine($"Имя: {name}"); }</span><span>}</span></code><br /><b>Глобальные пространства имен</b><br /><span>Определение глобальных пространств в отдельном файле</span><br /><span>Однако вышеуказанный подход опять же может быть не очень удобным, поскольку проще определить глобальные пространство имен, которые подключаются во весь проект где-то в одном месте. И для этого в Visual Studio 2022 мы можем добавить в проект новый файл с кодом C# и в нем определить набор подключаемых пространств имен. Например, добавим в проект файл, который назовем <code>GlobalUsings.cs</code> и в котором определим следующее содержимое:</span><br /><code><span>global using System.Text;</span></code><br /><code><span>global using System.Reflection;</span></code><br /><code><span>global using Base;</span></code><br /><span>И этот набор пространств имен будет автоматически подключаться во все файлы кода в проекте.</span></p>
            <p class="block1"><b>Создание библиотеки классов</b><br /><span>Нередко различные классы и структуры оформляются в виде отдельных библиотек, которые компилируются в файлы dll и затем могут подключаться в другие проекты. Благодаря этому мы можем определить один и тот же функционал в виде библиотеки классов и подключать в различные проекты или передавать на использование другим разработчикам.</span><br /><span>Создадим проект и подключим к нему библиотеку классов.</span><br /><span>Можно начать с создание библиотеки или сперва с создания основы программы</span><br /><span>Выберём 1 способ.</span><br><span>Создаём библиотеку классов</span></p>
            <p class="aligncenter"><img src="./../assets/img/cozdanieBibliotek1.jpg"></p>
            Далее в списке шаблонов проекта найдем пункт Class Library:<br>
            <p class="aligncenter"><img src="./../assets/img/cozdanieBibliotek2.jpg" ></p>
            <p class="block1">Затем дадим новому проекту какое-нибудь название:</p>
            <p class="aligncenter"><img src="./../assets/img/cozdanieBibliotek3.jpg" ></p>
            По умолчанию новый проект имеет один пустой класс Class1 в файле Class1.cs. Мы можем этот файл удалить или переименовать, как нам больше нравится.<br>
            Например, переименуем файл Class1.cs в Person.cs, а класс Class1 в Person. Определим в классе Person простейший код:<br>
            <p class="aligncenter"><img src="./../assets/img/cozdanieBibliotek4.jpg" ></p>
            Теперь скомпилируем библиотеку классов. Для этого нажмем правой кнопкой на проект библиотеки классов и в контекстном меню выберем пункт Rebuild(собрать или пересобрать выбираем):<br>
            <p class="aligncenter"><img class="img12" src="./../assets/img/cozdanieBibliotek8.jpg" ><br></p>
            После компиляции библиотеки классов в папке проекта в каталоге bin/Debug/net6.0 мы сможем найти скомпилированный файл dll (название библиотеки.dll). Подключим его в основной проект. Для этого в основном проекте нажмем правой кнопкой на узел Dependencies и в контекстном меню выберем пункт Add Project  (Добавить ссылку на проект)...:<br>
            <p class="aligncenter"><img src="./../assets/img/cozdanieBibliotek6.jpg" ></p>
            Далее нам откроется окно для добавления библиотек. В этом окне выберем пункт Solution (Решения),который позволяет увидеть все библиотеки классов из проектов текущего решения, поставим отметку рядом с нашей библиотекой и нажмем на кнопку OK:<br>
            <p class="aligncenter"><img src="./../assets/img/cozdanieBibliotek7.jpg" ></p>
            Если наша библиотека вдруг представляет файл dll, который не связан ни с каким проектом в нашем решении, то с помощью кнопки Browse мы можем найти местоположение файла dll и также его подключить.<br>
            После успешного подключения библиотеки в главном проекте изменим файл Program.cs, чтобы он использовал класс Person из библиотеки классов<br>
            Запускаем программу.<br>
            <p class="aligncenter"><img src="./../assets/img/cozdanieBibliotek5.jpg" ></p>
            <p><b>Модификаторы доступа</b><br /><span>Все поля, методы и остальные компоненты класса имеют модификаторы доступа. Модификаторы доступа позволяют задать допустимую область видимости для компонентов класса. То есть модификаторы доступа определяют контекст, в котором можно употреблять данную переменную или метод.</span><br /><span>В языке C# применяются следующие модификаторы доступа:</span></p>
            <ul>
              <li><code>private</code>: закрытый или приватный компонент класса или структуры. Приватный компонент доступен только в рамках своего класса или структуры.</li>
              <li><code>private protected</code>: компонент класса доступен из любого места в своем классе или в производных классах, которые определены в той же сборке.</li>
              <li><code>protected</code>: такой компонент класса доступен из любого места в своем классе или в производных классах. При этом производные классы могут располагаться в других сборках.</li>
              <li><code>internal</code>: компоненты класса или структуры доступен из любого места кода в той же сборке, однако он недоступен для других программ и сборок.</li>
              <li><code>protected internal</code>: совмещает функционал двух модификаторов protected и internal. Такой компонент класса доступен из любого места в текущей сборке и из производных классов, которые могут располагаться в других сборках.</li>
              <li><code>public</code>: публичный, общедоступный компонент класса или структуры. Такой компонент доступен из любого места в коде, а также из других программ и сборок.</li>
            </ul>
            <p><span>Стоит отметить, что эти модификаторы могут применяться как к компонентам класса, так и к компонентам структуры за тем исключением, что структуры не могут использовать модификаторы private protected, protected и protected internal, поскольку структуры не могут быть унаследованы.</span><br /><span>Все классы и структуры, определенные напрямую вне других типов (классов и структур) могут иметь только модификаторы public или internal.</span><br /><span>Мы можем явно задать модификатор доступа, а можем его и не указывать:</span><br /><code><span>public class Person</span></code><br /><code><span>{ string name;</span></code><br /><code><span>public Person(string name)</span></code><br /><code><span>{ this.name = name; }</span></code><br /><code><span>public void Print() =&gt; Console.WriteLine($"Name: {name}");</span><span>}</span></code><br /><b>Перегрузка методов</b><br /><span>Иногда возникает необходимость создать один и тот же метод, но с разным набором параметров. И в зависимости от имеющихся параметров применять определенную версию метода. Такая возможность еще называется перегрузкой методов (method overloading).</span><br /><span>И в языке C# мы можем создавать в классе несколько методов с одним и тем же именем, но разной сигнатурой. Что такое сигнатура? Сигнатура складывается из следующих аспектов:</span></p>
            <ul>
              <li>Имя метода</li>
              <li>Количество параметров</li>
              <li>Типы параметров</li>
              <li>Порядок параметров</li>
              <li>Модификаторы параметров</li>
            </ul>
            <p><span>о названия параметров в сигнатуру НЕ входят. Например, возьмем следующий метод:</span><br /><code><span>public int Sum(int x, int y)</span></code><br /><code><span>{ return x + y; }</span></code><br /><span>У данного метода сигнатура будет выглядеть так: <code>Sum(int, int)</code></span><br /><span>И перегрузка метода как раз заключается в том, что методы имеют разную сигнатуру, в которой совпадает только название метода. То есть методы должны отличаться по:</span></p>
            <ul>
              <li>Количеству параметров</li>
              <li>Типу параметров</li>
              <li>Порядку параметров</li>
              <li>Модификаторы параметров</li>
            </ul>
            <p><span>Например, пусть у нас есть следующий класс:</span><br /><code><span>class Calculator</span></code><br /><code><span>{ public void Add(int a, int b)</span></code><br /><code><span>{</span></code><br /><code><span>int result = a + b;</span></code><br /><code><span>Console.WriteLine($"Result is {result}");}</span></code><br /><code><span>public void Add(int a, int b, int c)</span></code><br /><code><span>{</span></code><br /><code><span>int result = a + b + c;</span></code><br /><code><span>Console.WriteLine($"Result is {result}"); }</span></code><br /><code><span>public void Add(double a, double b)</span></code><br /><code><span>{</span></code><br /><code><span>double result = a + b;</span></code><br /><code><span>Console.WriteLine($"Result is {result}"); }</span><span>}</span></code><br /><span>Здесь представлены три разных версии метода Add, то есть определены три перегрузки данного метода.</span><br /><span>Первые две версии метода отличаются по количеству параметров. Третья версия совпадает с первой по количеству параметров, но отличается по их типу. При этом достаточно, чтобы хотя бы один параметр отличался по типу. Поэтому это тоже допустимая перегрузка метода Add.</span><br /><span>о есть мы можем представить сигнатуры данных методов следующим образом:</span><br /><code><span>Add(int, int)</span></code><br /><code><span>Add(int, int, int)</span></code><br /><code><span>Add(double, double)</span></code><br /><span>После определения перегруженных версий мы можем использовать их в программе:</span><br /><code><span>Calculator calc = new Calculator();</span></code><br /><code><span>calc.Add(1, 2); // 3</span></code><br /><code><span>calc.Add(1, 2, 3); // 6</span></code><br /><code><span>calc.Add(1.4, 2.5); // 3.9</span></code><br /><span>Например, возьмём следующий набор методов:</span><br /><code><span>int Sum(int x, int y)</span></code><br /><code><span>{ return x + y; }</span></code><br /><code><span>int Sum(int number1, int number2)</span></code><br /><code><span>{ return number1 + number2; }</span></code><br /><code><span>void Sum(int x, int y)</span></code><br /><code><span>{ Console.WriteLine(x + y); }</span></code><br /><span>Сигнатура у всех этих методов будет совпадать:</span><br /><code><span>Sum(int, int)</span></code><br /><span>Поэтому данный набор методов не представляет корректные перегрузки метода Sum и работать не будет.</span><br /><b>Классы, структуры и пространства имён закончились</b></p>
          </div>
        </div>
      </div>
    </section>
    <nav class="container text-center">
      <router-link @click="scrollToTop()" to="/basicofprogramming"><button type="button" class="btn btn-primary">Основы программирования на C#</button></router-link>
      <router-link @click="scrollToTop()" to="/classstructures"><button type="button" class="btn btn-primary">Классы, структуры и пространства имён</button></router-link>
      <router-link @click="scrollToTop()" to="/objectorientedprogramming"><button type="button" class="btn btn-primary">ООП</button></router-link>
      <router-link @click="scrollToTop()" to="/exceptionhandling"><button type="button" class="btn btn-primary">Обработка исключений</button><br><br></router-link>
      <router-link @click="scrollToTop()" to="/delegate"><button type="button" class="btn btn-primary">Делегаты, события и лямбды</button></router-link>
      <router-link @click="scrollToTop()" to="/interfacee"><button type="button" class="btn btn-primary">Интерфейсы</button></router-link>
      <router-link @click="scrollToTop()" to="/dopioop"><button type="button" class="btn btn-primary">Дополнительны возможности ООП в C#</button><br><br></router-link>
      <router-link @click="scrollToTop()" to="/programmingigr"><button type="button" class="btn btn-primary justify-content-center">Программирование игр</button></router-link>
    </nav>
  </div>
</template>

<script>
export default {
  name: "classstructures",

  methods: {
    scrollToTop() {
      window.scrollTo(0, 0);
    },
  }
}
</script>

<style scoped>


p{
  font-size: 14px;
  text-indent: 25px;
}
.aligncenter{
  text-align: center;
  margin: 0;
  padding: 0;
}
@media (max-width: 768px) {
  #menu-btn {
    display: inline-block;
  }

  .home-main .home-parallax-img {
    top: 0;
    right: 0;
    width: 100%;
  }

  .grid-banner .content h3 {
    font-size: 15px !important;
  }

  .grid-banner .content.center {
    padding-left: 0px !important;
  }
  img{
    width:auto ;
    height: auto;
  }

}

@media (max-width: 576px) {
  .home-main .content h3 {
    font-size: 3rem;
  }

  .home-main .content p {
    font-size: 1.5rem;
  }

  img {
    width:300px ;
    height: 250px;
  }
  .img12{
    width: 300px ;
    height: 100px;
  }
}

</style>