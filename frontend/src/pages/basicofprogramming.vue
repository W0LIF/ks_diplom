<template>
  <div class="container">
    <section class="py-0">
      <div class="mb-4  justify-content-between align-items-center text-center">
        <h2>Основы программирования на C#</h2>
      </div>
      <div class="row">
        <div class="card mb-3 shadow-lg p-0 pb-3">
          <div>
            <h4 style="text-align: center;">Программирование - основы</h4>
            <div  style="text-align: left;"><b>Типы данных:</b></div>
            <ul>
              <li>Целые типы: sbyte, byte, short, ushort, int, uint, long, ulong.</li>
              <li>Типы, в которых сохраняются данные с плавающей запятой (соответствуют вещественному типу): float, double, decimal.</li>
              <li>Символьный тип: char.</li>
              <li>Логический тип: bool.</li>
              <li>Строчный тип: string.</li>
            </ul>
            <div><b>Описание переменной:</b></div>
            <div>Описание задаётся так int (тип переменной) a (имя переменной) -<span>&nbsp;</span><code>int a;</code><br />
              <div><b>Присваивания переменной:</b><br /></div><div><span>Присваивание значения переменной после ее описания.</span><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int a;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a = 10;</code><span></span><br /><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;или</span><br /><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Присваивание значения переменной во время ее описания (начальная инициализация).</span><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int a = 10;</code><strong></strong></div>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Присваивание значения переменной после операций<br />
              <ul>
                <li>+= - присваивание после сложения: a += 10;</li>
                <li>-= - присваивание после вычитания: a -= 4;</li>
                <li>*= - присваивание после умножения: a *= 10;</li>
                <li>/= - присваивание после деления: a /= 10;</li>
                <li>%= присваивание после деления по модулю: a %= 10;</li>
                <li>&amp;= присваивание после поразрядной конъюнкции: a &amp;= 10;</li>
                <li>|= присваивание после поразрядной дизъюнкции: a |= 10;</li>
                <li>^= присваивание после операции исключающего ИЛИ.: a ^= 10;</li>
                <li>&lt;&lt;= - присваивание после сдвига разрядов влево: a &lt;&lt;= 10;</li>
                <li>&gt;&gt;= - присваивание после сдвига разрядов вправо: a &gt;&gt;= 10;</li>
              </ul>
              <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ввод и вывод данных:</b><br />Ввод осуществляется с помощью команды -<span>&nbsp;</span><code>Console.ReadLine();</code><br /><code>Console.Read()</code><span>&nbsp;</span>- не добавляет переход на следующую строку<br />Вывод осуществляется с помощью команды -<span>&nbsp;</span><code>Console.WriteLine()</code><span>&nbsp;</span>или<span>&nbsp;</span><code>Console.Write()</code><br /><code>Console.Write()</code><span>&nbsp;</span>- не добавляет переход на следующую строку<br /><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Преобразование данные введённый данные в конкретный тип данных:</b><br /><code>Convert.ToInt32()<span>&nbsp;</span></code>(преобразует к типу int)<br /><code>Convert.ToDouble()</code><span>&nbsp;</span>(преобразует к типу double)<br /><code>Convert.ToDecimal()<span>&nbsp;</span></code>(преобразует к типу decimal)<br />Пример:<br /><code>Console.Write("Введите возраст: ");<br />int age = Convert.ToInt32(Console.ReadLine());</code><br /><b>&nbsp;&nbsp;&nbsp;Арифметические операции:</b><br />В C# используется большинство операций, которые применяются и в других языках программирования. Операции представляют определенные действия над операндами - участниками операции. В качестве операнда может выступать переменной или какое-либо значение (например, число). Операции бывают унарными (выполняются над одним операндом), бинарными - над двумя операндами и тернарными - выполняются над тремя операндами.<br />Бинарные арифметические операции:
              <ul>
                <li>+ - Операция сложения двух чисел:<br /><code>int x = 10;<br />int z = x + 12; // 22</code></li>
                <li>- - Операция вычитания двух чисел:<br /><code>int x = 10;<br />int z = x - 6; // 4</code></li>
                <li>* - Операция умножения двух чисел:<br /><code>int x = 10;<br />int z = x * 12; // 120</code></li>
                <li>/ - Операция деления двух чисел:<br />int x = 10;<br /><code>int z = x / 5; // 2<br />double a = 10;<br />double b = 3;<br />double c = a / b; // 3.33333333</code></li>
                <li>% - Операция получение остатка от целочисленного деления двух чисел:<br /><code>double x = 10.0;<br />double z = x % 4.0; //результат равен 2</code></li>
              </ul>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Унарные операции:
              <ul>
                <li>++ - Операция инкремента:<br /><code>int x1 = 5;<br />int z1 = ++x1; // z1=6; x1=6<br />Console.WriteLine($"{x1} - {z1}");</code></li>
                <li>-- - Операция декремента или уменьшения значения на единицу:<br /><code>int x1 = 5;<br />int z1 = --x1; // z1=4; x1=4<br />Console.WriteLine($"{x1} - {z1}");</code></li>
              </ul>
              <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Конструкция<span>&nbsp;</span><code>if..else</code><span>&nbsp;</span>и тернарная операция</b><span>&nbsp;</span>Условные конструкции - один из базовых компонентов многих языков программирования, которые направляют работу программы по одному из путей в зависимости от определенных условий. Одной из таких конструкций в языке программирования C# является конструкция<span>&nbsp;</span><code>if..else</code><br />Конструкция<span>&nbsp;</span><code>if/else</code><span>&nbsp;</span>проверяет истинность некоторого условия и в зависимости от результатов проверки выполняет определенный код.<br />Ее простейшая форма состоит из блока<span>&nbsp;</span><code>if:</code><br /><code>if(условие)<br />{ выполняемые инструкции }</code><br />Например:<br /><code>int num1 = 8;<br />int num2 = 6;<br />if(num1 &gt; num2)<br />{ Console.WriteLine($"Число {num1} больше числа {num2}"); }</code><br />Но что, если мы захотим, чтобы при несоблюдении условия также выполнялись какие-либо действия? В этом случае мы можем добавить блок<span>&nbsp;</span><code>else</code>:<span>&nbsp;</span><code>if(условие)<br />{ выполняемые инструкции }<br />else{ выполняемые инструкции }</code><br />Тернарная операция<br />Тернарную операция также позволяет проверить некоторое условие и в зависимости от его истинности выполнить некоторые действия. Она имеет следующий синтаксис:<br />[первый операнд - условие] ? [второй операнд] : [третий операнд]<br />Например:<br /><code>int x=3;<br />int y=2;<br />int z = x &lt; y ? (x+y) : (x-y);<br />Console.WriteLine(z); // 1</code><br /><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Циклы</b><br />Циклы являются управляющими конструкциями, позволяя в зависимости от определенных условий выполнять некоторое действие множество раз. В C# имеются следующие виды циклов:<br />
              <ul>
                <li><code>for</code><span>&nbsp;</span>- имеет следующее формальное определение:<br /><code>for ([действия_до_выполнения_цикла]; [условие]; [действия_после_выполнения])<br />{ // действия }</code><br />Например<br /><code>for (int i = 1; i &lt; 4; i++)<br />{ Console.WriteLine(i); }</code></li>
                <li><code>foreach</code><span>&nbsp;</span>- предназначен для перебора набора или коллекции элементов. Его общее определение:<span>&nbsp;</span><code>foreach(тип_данных переменная in коллекция)<br />{ // действия цикла }</code><br />Например:<br /><code>foreach(char c in "Tom")<br />{ Console.WriteLine(c); }</code></li>
                <li><code>while</code>- В отличие от цикла do цикл while сразу проверяет истинность некоторого условия, и если условие истинно, то код цикла выполняется:<br /><code>while (условие)<br />{ действия цикла }</code><br />Например:<br /><code>int i = 6;<br />while (i &gt; 0)<br />{ Console.WriteLine(i); i--; }</code></li>
                <li><code>do...while</code><span>&nbsp;</span>- В цикле<span>&nbsp;</span><code>do</code><span>&nbsp;</span>сначала выполняется код цикла, а потом происходит проверка условия в инструкции<span>&nbsp;</span><code>while</code>. И пока это условие истинно, цикл повторяется.<br /><code>do { действия цикла }<br />while (условие)</code><br />Например:<br /><code>int i = 6;<br />do { Console.WriteLine(i); i--; }<br />while (i &gt; 0);</code></li>
              </ul>
              Циклы бывают вложенными<br />Одни циклы могут быть вложенными в другие. Например:<br /><code>for (int i = 1; i &lt; 10; i++)<br />{ for (int j = 1; j &lt; 10; j++)<br />{ Console.Write($"{i * j} \t"); }<br />Console.WriteLine(); }</code><br />В данном случае цикл<span>&nbsp;</span><code>for (int i = 1; i &lt; 10; i++)</code><span>&nbsp;</span>выполняется 9 раз, то есть имеет 9 итераций. Но в рамках каждой итерации выполняется девять раз вложенный цикл<span>&nbsp;</span><br><code>for (int j = 1; j &lt; 10; j++)</code>. В итоге данная программа выведет таблицу умножения.</div>
            <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Массивы</b><br />Массив представляет набор однотипных данных. Объявление массива похоже на объявление переменной за тем исключением, что после указания типа ставятся квадратные скобки:<br /><code>тип_переменной[] название_массива;</code><br />Например, определим массив целых чисел:<br />int[] numbers;<br />После определения переменной массива мы можем присвоить ей определенное значение:<br /><code>int[] nums = new int[4];</code><br />мы сразу можем указать значения для этих элементов:<br /><code>int[] nums2 = new int[4] { 1, 2, 3, 5 };</code><br /><code>int[] nums3 = new int[] { 1, 2, 3, 5 };</code><br /><code>int[] nums4 = new[] { 1, 2, 3, 5 };</code><br /><code>int[] nums5 = { 1, 2, 3, 5 };</code><br />Все перечисленные выше способы будут равноценны.<br />Подобным образом можно определять массивы и других типов, например, массив значений типа string:<br /><code>string[] people = { "Tom", "Sam", "Bob" };</code><br />Индексы и получение элементов массива<br />Для обращения к элементам массива используются индексы. Индекс представляет номер элемента в массиве, при этом нумерация начинается с нуля, поэтому индекс первого элемента будет равен 0, индекс четвертого элемента - 3.<br />Используя индексы, мы можем получить элементы массива:<br />int[] numbers = { 1, 2, 3, 5 };<br />// получение элемента массива<br />Console.WriteLine(numbers[3]); // 5<br />// получение элемента массива в переменную<br />var n = numbers[1]; // 2<br />Console.WriteLine(n); // 2<br />Также мы можем изменить элемент массива по индексу:<br /><code>int[] numbers = { 1, 2, 3, 5 };</code><br /><code>// изменим второй элемент массива</code><br /><code>numbers[1] = 505;</code><br /><code>Console.WriteLine(numbers[1]); // 505</code><br />Получение элементов с конца массива<br />Благодаря наличию свойства Length, мы можем вычислить индекс последнего элемента массива - это длина массива - 1. Например, если длина массива - 4 (то есть массив имеет 4 элемента), то индекс последнего элемента будет равен 3. И, используя свойство Length, мы можем легко получить элементы с конца массива:<br /><code>int[] numbers = { 1, 2, 3, 5};</code><br /><code>Console.WriteLine(numbers[numbers.Length - 1]); // 5 - первый с конца или последний элемент</code><br /><code>Console.WriteLine(numbers[numbers.Length - 2]); // 3 - второй с конца или предпоследний элемент</code><br /><code>Console.WriteLine(numbers[numbers.Length - 3]); // 2 - третий элемент с конца</code><br />Перебор массивов<br />Для перебора массивов мы можем использовать различные типы циклов. Например, цикл&nbsp;foreach:<br /><code>int[] numbers = { 1, 2, 3, 4, 5 };</code><br /><code>foreach (int i in numbers)</code><br /><code>{ Console.WriteLine(i); }</code><br />Здесь в качестве контейнера выступает массив данных типа int. Поэтому мы объявляем переменную с типом int<br />Многомерные массивы<br />Массивы характеризуются таким понятием как ранг или количество измерений. Выше мы рассматривали массивы, которые имеют одно измерение (то есть их ранг равен 1) - такие массивы можно представлять в виде ряда (строки или столбца) элемента. Но массивы также бывают многомерными. У таких массивов количество измерений (то есть ранг) больше 1.<br />Массивы которые имеют два измерения (ранг равен 2) называют двухмерными. Например, создадим одномерный и двухмерный массивы, которые имеют одинаковые элементы:<br /><code>int[] nums1 = new int[] { 0, 1, 2, 3, 4, 5 };</code><br /><code>int[,] nums2 = { { 0, 1, 2 }, { 3, 4, 5 } };</code><br /><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Методы</b><br /><span>Если переменные хранят некоторые значения, то методы содержат собой набор инструкций, которые выполняют определенные действия. По сути метод - это именованный блок кода, который выполняет некоторые действия.</span><br /><span>Общее определение методов выглядит следующим образом:</span><br /><code>[модификаторы] тип_возвращаемого_значения название_метода ([параметры])<br />{ // тело метода }</code><br /><span>Определение метода</span><br /><span>Определим один метод:</span><br /><code>void SayHello()<br />{ Console.WriteLine("Hello"); }</code><br /><span>Вызов методов Чтобы использовать метод&nbsp;</span><code>SayHello</code><span>, нам надо его вызвать. Для вызова метода указывается его имя, после которого в скобках идут значения для его параметров (если метод принимает параметры).</span><br /><code>название_метода (значения_для_параметров_метода);</code><br /><span>Например, вызов метода&nbsp;</span><code>SayHello</code><span>&nbsp;будет выглядеть следующим образом:</span><br /><code>SayHello();</code><br /><span>Поскольку метод не принимает никаких параметров, то после названия метода идут пустые скобки.</span><br /><span>Сокращенная запись методов</span><br /><span>Мы можем его сократить следующим образом:</span><br /><code>void SayHello() =&gt; Console.WriteLine("Hello");</code><br /><span>То есть после списка параметров ставится оператор =&gt;, после которого идет выполняемая инструкция.</span><br /><span>Параметры методов</span><br /><span>Параметры позволяют передать в метод некоторые входные данные. Параметры определяются через запятую в скобках после названия метода в виде:</span><br /><code>тип_метода имя_метода (тип_параметра1 параметр1, тип_параметра2 параметр2, ...)<br />{ // действия метода }</code><br /><span>Например:</span><br /><code>void Sum(int x, int y) =&gt; Console.WriteLine($"{x} + {y} = { x + y }");<br />Sum(10, 15); // 10 + 15 = 25</code><br /><span>Возвращение значения и оператор return Метод может возвращать значение, какой-либо результат. В примере выше были определены два метода, которые имели тип&nbsp;</span><code>void</code><span>. Методы с таким типом не возвращают никакого значения. Они просто выполняют некоторые действия.</span><br /><span>Но методы также могут возвращать некоторое значение. Для этого применяется оператор return, после которого идет возвращаемое значение:</span><br /><code>return</code><span>&nbsp;возвращаемое значение;</span><br /><span>Например, определим метод, который возвращает значение типа string:</span><br /><code>string GetMessage()<br />{ return "Hello"; }</code><br /><span>Метод&nbsp;</span><code>GetMessage</code><span>&nbsp;имеет тип string, следовательно, он должен возвратить строку. Поэтому в теле метода используется оператор return, после которого указана возвращаемая строка.</span><br /><span>Оператор return не только возвращает значение, но и производит выход из метода. Поэтому он должен определяться после остальных инструкций.</span><br /><b>&nbsp;&nbsp;&nbsp;Рекурсивные функции</b><br /><span>Рекурсивная функция представляет такую конструкцию, при которой функция вызывает саму себя.</span><br /><span>Рекурсивная функция факториала</span><br /><span>Возьмем, к примеру, вычисление факториала, которое использует формулу n! = 1 * 2 * &hellip; * n. То есть по сути для нахождения факториала числа мы перемножаем все числа до этого числа. Например, факториал числа 4 равен 24 = 1 * 2 * 3 * 4, а факториал числа 5 равен 120 = 1 * 2 * 3 * 4 * 5.</span><br /><span>Определим метод для нахождения факториала:</span><br /><code>int Factorial(int n)<br />{ if (n == 1) return 1;<br />return n * Factorial(n - 1); }</code><br /><span>При создании рекурсивной функции в ней обязательно должен быть некоторый базовый вариант, с которого начинается вычисление функции. В случае с факториалом это факториал числа 1, который равен 1. Факториалы всех остальных положительных чисел будет начинаться с вычисления факториала числа 1, который равен 1.</span><br /><span>Функция с примером</span><br /><code>int Factorial(int n)<br />{ if (n == 1) return 1;<br />return n * Factorial(n - 1); }<br />int factorial4 = Factorial(4); // 24<br />int factorial5 = Factorial(5); // 120<br />int factorial6 = Factorial(6); // 720<br />Console.WriteLine($"Факториал числа 4 = {factorial4}");<br />Console.WriteLine($"Факториал числа 5 = {factorial5}");<br />Console.WriteLine($"Факториал числа 6 = {factorial6}");</code><br /><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Конструкция<span>&nbsp;</span><code>switch</code></b><br /><span>
              Конструкция&nbsp;</span><code>switch/case</code><span>&nbsp;оценивает некоторое выражение и сравнивает его значение с набором значений. И при совпадении значений выполняет определенный код.:</span><br /><span>Конструкция&nbsp;</span><code>switch</code><span>&nbsp;имеет следующее формальное определение:</span><br /><code>switch (выражение)<br />{ case значение1:<br />код,выполняемый если выражение имеет значение1<br />break;<br />case значение2:<br />код,выполняемый если выражение имеет значение1<br />break;<br />//.............<br />case значениеN:<br />код, выполняемый если выражение имеет значениеN<br />break;<br />default:<br />код, выполняемый если выражение не имеет ни одно из выше указанных значений<br />break; }</code><br /><span>После ключевого слова switch в скобках идет сравниваемое выражение. Значение этого выражения последовательно сравнивается со значениями, помещенными после оператора&nbsp;</span><code>сase</code><span>. И если совпадение будет найдено, то будет выполняться определенный блок&nbsp;</span><code>сase</code><span>.</span><br /><span>В конце каждого блока&nbsp;</span><code>сase</code><span>&nbsp;должен ставиться один из операторов перехода:&nbsp;</span><code>break, goto case, return или throw</code><span>. Как правило, используется оператор break. При его применении другие блоки case выполняться не будут.</span><br /><span>Например:</span><br /><code>string name = "Tom";<br />switch (name)<br />{ case "Bob":<br />Console.WriteLine("Ваше имя - Bob");<br />break;<br />case "Tom":<br />Console.WriteLine("Ваше имя - Tom");<br />break;<br />case "Sam":<br />Console.WriteLine("Ваше имя - Sam");<br />break;}</code><br /><span>В данном случае конструкция switch последовательно сравнивает значение переменной name с набором значений, которые указаны после операторов case. Поскольку здесь значение переменной name - строка "Tom", то будет выполняться блок</span><br /><code>case "Tom":<br />Console.WriteLine("Ваше имя - Tom");<br />break;</code><span></span><br /><span>Соответственно мы увидим это на консоли</span></p>

            <div><b>Перечисления<span>&nbsp;</span><code>enum</code></b><br /><span>Кроме примитивных типов данных в языке программирования C# есть такой тип как enum или перечисление. Перечисления представляют набор логически связанных констант.</span><br /><span>Объявление перечисления происходит с помощью оператора enum:</span><br /><code>enum название_перечисления<br />{ // значения перечисления<br />значение1,<br />значение2,<br />.......<br />значениеN }</code><br /><span>После оператора enum идет название перечисления. И затем в фигурных скобках через запятую перечисляются константы перечисления.</span><br /><span>Определим простейшее перечисление:</span><br /><code>enum DayTime<br />{ Morning,<br />Afternoon,<br />Evening,<br />Night }</code><br /><span>Здесь определено перечисление&nbsp;</span><code>DayTime</code><span>, которое имеет четыре значения:&nbsp;</span><code>Morning, Afternoon, Evening и Night</code><br /><span>Каждое перечисление фактически определяет новый тип данных, с помощью которых мы также, как и с помощью любого другого типа, можем определять переменные, константы, параметры методов и т.д. В качестве значения переменной, константы и параметра метода, которые представляют перечисление, должна выступать одна из констант этого перечисления, например:</span><br /><code>const DayTime dayTime = DayTime.Morning;</code><br /><span>Далее в программе мы можем использовать подобные переменные/константы/параметры как и любые другие:</span><br /><code>DayTime dayTime = DayTime.Morning;<br />if(dayTime == DayTime.Morning)<br />Console.WriteLine("Доброе утро");<br />else<br />Console.WriteLine("Привет");<br />enum DayTime<br />{ Morning,<br />Afternoon,<br />Evening,<br />Night }</code><br /><b>На этом основы программирования C# закончились</b></div>
          </div>
        </div>
      </div>
    </section>
  </div>
  <nav class="container text-center">
    <router-link @click="scrollToTop()" to="/basicofprogramming"><button type="button" class="btn btn-primary">Основы программирования на C#</button></router-link>
    <router-link @click="scrollToTop()" to="/classstructures"><button type="button" class="btn btn-primary">Классы, структуры и пространства имён</button></router-link>
    <router-link @click="scrollToTop()" to="/objectorientedprogramming"><button type="button" class="btn btn-primary">ООП</button></router-link>
    <router-link @click="scrollToTop()" to="/exceptionhandling"><button type="button" class="btn btn-primary">Обработка исключений</button><br><br></router-link>
    <router-link @click="scrollToTop()" to="/delegate"><button type="button" class="btn btn-primary">Делегаты, события и лямбды</button></router-link>
    <router-link @click="scrollToTop()" to="/interfacee"><button type="button" class="btn btn-primary">Интерфейсы</button></router-link>
    <router-link @click="scrollToTop()" to="/dopioop"><button type="button" class="btn btn-primary">Дополнительны возможности ООП в C#</button><br><br></router-link>
    <router-link @click="scrollToTop()" to="/programmingigr"><button type="button" class="btn btn-primary justify-content-center">Программирование игр</button></router-link>
  </nav>
</template>

<script>
export default {
  name: "basicofprogramming"
}
</script>

<style scoped>
div{
  font-size: 16px;
  text-indent: 25px;
}
p{
  text-indent: 25px;
  margin-bottom: 0;
}
ul{
  list-style-position: inside;
  font-size: 16px;
}
</style>