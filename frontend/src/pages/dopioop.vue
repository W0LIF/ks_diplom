<template>
  <div class="container">
    <section class="py-0">
      <div class="mb-4  justify-content-between align-items-center text-center">
        <h2>Дополнительны возможности ООП в C# </h2>
      </div>
      <div class="row">
        <div class="card mb-3 shadow-lg p-0 pb-3">
          <div>
            <p><b>Определение операторов</b><br /><span>Наряду с методами в классах и структурах мы можем также определять операторы.</span><br /><span>Определение операторов заключается в определении в классе, для объектов которого мы хотим определить оператор, специального метода:</span><br /><code><span>public static возвращаемый_тип operator оператор(параметры)</span><span>{ }</span></code><br /><span>Этот метод должен иметь модификаторы public static, так как перегружаемый оператор будет использоваться для всех объектов данного класса. Далее идет название возвращаемого типа. Возвращаемый тип представляет тот тип, объекты которого мы хотим получить.</span><br /><span>Определение операций true и false</span><br /><span>Отдельно стоит отметить определение операторов true и false. Эти операторы определяются, когда мы хотим использовать объект типа в качестве условия. Например, определим данные операторы в классе Counter:</span><br /><code><span>class Counter</span></code><br /><code><span>{</span></code><br /><code><span>public int Value { get; set; }</span></code><br /><code><span>public static bool operator true(Counter counter1)</span></code><br /><code><span>{ return counter1.Value != 0; }</span></code><br /><code><span>public static bool operator false(Counter counter1)</span></code><br /><code><span>{ return counter1.Value == 0; } }</span></code><br /><span>Например:</span><br /><code><span>Counter counter = new Counter() { Value = 0 };</span></code><br /><code><span>if (counter)</span></code><br /><code><span>Console.WriteLine(true);</span></code><br /><code><span>else</span></code><br /><code><span>Console.WriteLine(false);</span></code><br /><span>Также стоит отметить, что если мы хотим использовать операцию отрицания, типа if (!counter), то нам также необходимо определить для типа операцию !:</span><br /><code><span>Counter counter = new Counter() { Value = 2 };</span></code><br /><code><span>if (!counter)</span></code><br /><code><span>Console.WriteLine(true);</span></code><br /><code><span>else</span></code><br /><code><span>Console.WriteLine(false);</span></code><br /><code><span>class Counter</span></code><br /><code><span>{</span></code><br /><code><span>public int Value { get; set; }</span></code><br /><code><span>public static bool operator !(Counter counter1)</span></code><br /><code><span>{ return counter1.Value == 0; }</span></code><br /><code><span>public static bool operator true(Counter counter1)</span></code><br /><code><span>{ return counter1.Value != 0; }</span></code><br /><code><span>public static bool operator false(Counter counter1)</span></code><br /><code><span>{ return counter1.Value == 0; } }</span></code><br /><b>Индексаторы</b><br /><span>Индексаторы позволяют индексировать объекты и обращаться к данным по индексу. Фактически с помощью индексаторов мы можем работать с объектами как с массивами. По форме они напоминают свойства со стандартными блоками get и set, которые возвращают и присваивают значение.</span><br /><span>Формальное определение индексатора:</span><br /><code><span>возвращаемый_тип this [Тип параметр1, ...]</span></code><br /><code><span>{</span></code><br /><code><span>get { ... }</span></code><br /><code><span>set { ... }</span></code><br /><code><span>}</span></code><br /><span>В отличие от свойств индексатор не имеет названия. Вместо него указывается ключевое слово this, после которого в квадратных скобках идут параметры. Индексатор должен иметь как минимум один параметр.</span><br /><span>Индексы</span><br /><span>Индексатор получает набор индексов в виде параметров. Однако индексы необязательно должны представлять тип int, устанавливаемые/возвращаемые значения необязательно хранить в массиве. Например, мы можем рассматривать объект как хранилище атрибутов/свойств и передавать имя атрибута в виде строки:</span><br /><code><span>User tom = new User();</span></code><br /><code><span>// устанавливаем значения</span></code><br /><code><span>tom["name"] = "Tom";</span></code><br /><code><span>tom["email"] = "tom@gmail.ru";</span></code><br /><code><span>tom["phone"] = "+1234556767";</span></code><br /><code><span>// получаем значение</span></code><br /><code><span>Console.WriteLine(tom["name"]); // Tom</span></code><br /><code><span>class User</span></code><br /><code><span>{</span></code><br /><code><span>string name = "";</span></code><br /><code><span>string email = "";</span></code><br /><code><span>string phone = "";</span></code><br /><code><span>public string this[string propname] {</span></code><br /><code><span>get {</span></code><br /><code><span>switch (propname) {</span></code><br /><code><span>case "name": return name;</span></code><br /><code><span>case "email": return email;</span></code><br /><code><span>case "phone": return phone;</span></code><br /><code><span>default: throw new Exception("Unknown Property Name");</span></code><br /><code><span>} }</span></code><br /><code><span>set</span></code><br /><code><span>{ switch (propname) {</span></code><br /><code><span>case "name":</span></code><br /><code><span>name = value;</span></code><br /><code><span>break;</span></code><br /><code><span>case "email":</span></code><br /><code><span>email = value;</span></code><br /><code><span>break;</span></code><br /><code><span>case "phone":</span></code><br /><code><span>phone = value;</span></code><br /><code><span>break; } } } }</span></code><br /><span>В данном случае индексатор в классе User в качестве индекса получает строку, которая хранит название атрибута (в данном случае название поля класса).</span><br /><span>В блоке get в зависимости от значения строкового индекса возвращается значение того или иного поля класса. Если передано неизвестное название, то генерируется исключение. В блоке set похожая логика - по индексу узнаем, для какого поля надо установить значение.</span><br /><span>Применение нескольких параметров</span><br /><span>Также индексатор может принимать несколько параметров. Допустим, у нас есть класс, в котором хранилище определено в виде двухмерного массива или матрицы:</span><br /><code><span>class Matrix</span></code><br /><code><span>{</span></code><br /><code><span>int[,] numbers = new int[,] { { 1, 2, 4 }, { 2, 3, 6 }, { 3, 4, 8 } };</span></code><br /><code><span>public int this[int i, int j]</span></code><br /><code><span>{</span></code><br /><code><span>get =&gt; numbers[i, j];</span></code><br /><code><span>set =&gt; numbers[i, j] = value; } }</span></code><br /><span>Теперь для определения индексатора используются два индекса - i и j. И в программе мы уже должны обращаться к объекту, используя два индекса:</span><br /><code><span>Matrix matrix = new Matrix();</span></code><br /><code><span>Console.WriteLine(matrix[0, 0]);</span></code><br /><code><span>matrix[0, 0] = 111;</span></code><br /><code><span>Console.WriteLine(matrix[0, 0]);</span></code><br /><span>Следует учитывать, что индексатор не может быть статическим и применяется только к экземпляру класса. Но при этом индексаторы могут быть виртуальными и абстрактными и могут переопределяться в произодных классах.</span></p>
            <p><b>Переменные-ссылки и возвращение ссылки</b><br /><span>Кроме параметров метода, которые с помощью модификатора ref позволяют передавать значение по ссылке, C# также позволяет с помощью ключевого слова ref возвращать ссылку из метода и определять переменную, которая будет хранить ссылку.</span><br /><span>Переменная-ссылка</span><br /><span>Для определения локальной переменной-ссылки (ref local) перед ее типом ставится ключевое слово ref:</span><br /><code><span>int x = 5;</span></code><br /><code><span>ref int xRef = ref x;</span></code><br /><span>Здесь переменная xRef указывает не просто на значение переменной x, а на область в памяти, где располагается эта переменная. Для этого перед x также указывается ref.</span><br /><span>При этом мы не можем просто определить переменную-ссылку, нам обязательно надо присвоить ей некоторое значение. Так, следующий код вызовет ошибку:</span><br /><code><span>ref int xRef; // ошибка</span></code><br /><span>Получив ссылку, мы можем манипулировать значением по этой ссылке. Например:</span><br /><code><span>int x = 5;</span></code><br /><code><span>ref int xRef = ref x;</span></code><br /><code><span>Console.WriteLine(x); // 5</span></code><br /><code><span>xRef = 125;</span></code><br /><code><span>Console.WriteLine(x); // 125</span></code><br /><code><span>x = 625;</span></code><br /><code><span>Console.WriteLine(xRef); // 625 Ссылка как результат функции</span></code><br /><span>Для возвращения из функции ссылки в сигнатуре функции перед возвращаемым типом, а также после оператора return следует указать ключевое слово ref:</span><br /><span>i<code>nt[] numbers = { 1, 2, 3, 4, 5, 6, 7 };</code></span><br /><code><span>ref int numberRef = ref Find(4, numbers); // ищем число 4 в массиве</span></code><br /><code><span>numberRef = 9; // заменяем 4 на 9</span></code><br /><code><span>Console.WriteLine(numbers[3]); // 9</span></code><br /><code><span>ref int Find(int number, int[] numbers) {</span></code><br /><code><span>for (int i = 0; i &lt; numbers.Length; i++) {</span></code><br /><code><span>if (numbers[i] == number) {</span></code><br /><code><span>return ref numbers[i]; // возвращаем ссылку на адрес, а не само значение</span></code><br /><code><span>} }</span></code><br /><code><span>throw new IndexOutOfRangeException("число не найдено"); }</span></code><br /><span>В методе Find ищем число в массиве, но вместо самого значения числа возвращаем ссылку на него в памяти. Для этого в сигнатуре метода в качестве типа результата функции указывается не просто int, а ref int.</span><br /><span>Кроме того, в самом методе после слова return также ставится ref:</span><br /><code><span>return ref numbers[i];</span></code><br /><span>Тем самым мы получаем не просто значение, а ссылку на объект в памяти.</span><br /><span>В методе Main для определения переменной, которая будет содержать ссылку, используется ключевое слово ref. При вызове метода также указывается слово ref:</span><br /><code><span>ref int numberRef = ref Find(7, numbers);</span></code><br /><span>В итоге переменная numberRef будет содержать ссылку на объект int, и через данную переменную в последствиии мы можем изменить объект по этой ссылке.</span><br /><span>При определении метода, который возвращает ссылку, следует учитывать, что такой метод естественно не может иметь тип void. Кроме того, такой метод не может возвращать:</span></p>
            <ul>
              <li>Значение null</li>
              <li>Константу</li>
              <li>Значение перечисления enum</li>
              <li>Свойство класса или структуры</li>
              <li>Поле для чтения (которое имеет модификатор read-only)</li>
            </ul>
            <p><b>Дополнительный возможности в ООП всё</b></p>
          </div>
        </div>
      </div>
    </section>
  </div>
  <nav class="container text-center">
    <router-link @click="scrollToTop()" to="/basicofprogramming"><button type="button" class="btn btn-primary">Основы программирования на C#</button></router-link>
    <router-link @click="scrollToTop()" to="/classstructures"><button type="button" class="btn btn-primary">Классы, структуры и пространства имён</button></router-link>
    <router-link @click="scrollToTop()" to="/objectorientedprogramming"><button type="button" class="btn btn-primary">ООП</button></router-link>
    <router-link @click="scrollToTop()" to="/exceptionhandling"><button type="button" class="btn btn-primary">Обработка исключений</button><br><br></router-link>
    <router-link @click="scrollToTop()" to="/delegate"><button type="button" class="btn btn-primary">Делегаты, события и лямбды</button></router-link>
    <router-link @click="scrollToTop()" to="/interfacee"><button type="button" class="btn btn-primary">Интерфейсы</button></router-link>
    <router-link @click="scrollToTop()" to="/dopioop"><button type="button" class="btn btn-primary">Дополнительны возможности ООП в C#</button><br><br></router-link>
    <router-link @click="scrollToTop()" to="/programmingigr"><button type="button" class="btn btn-primary justify-content-center">Программирование игр</button></router-link>
  </nav>
</template>

<script>
export default {
  name: "dopioop",

  methods: {
    scrollToTop() {
      window.scrollTo(0, 0);
    },
  }
}
</script>

<style scoped>
p{
  font-size: 14px;
}
</style>