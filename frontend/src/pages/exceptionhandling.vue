<template>
  <div class="container">
    <section class="py-0">
      <div class="mb-4  justify-content-between align-items-center text-center">
        <h2>Обработка исключений </h2>
      </div>
      <div class="row">
        <div class="card mb-3 shadow-lg p-0 pb-3">
          <div>
            <p><b>Конструкция try..catch..finally</b><br /><span>Иногда при выполнении программы возникают ошибки, которые трудно предусмотреть или предвидеть, а иногда и вовсе невозможно. Например, при передачи файла по сети может неожиданно оборваться сетевое подключение. такие ситуации называются исключениями. Язык C# предоставляет разработчикам возможности для обработки таких ситуаций. Для этого в C# предназначена конструкция try...catch...finally.</span><br /><code><span>try</span></code><br /><code><span>{ }</span></code><br /><code><span>catch</span></code><br /><code><span>{ }</span></code><br /><code><span>finally</span></code><br /><code><span>{ }</span></code><br /><span>При использовании блока try...catch..finally вначале выполняются все инструкции в блоке try. Если в этом блоке не возникло исключений, то после его выполнения начинает выполняться блок finally. И затем конструкция try..catch..finally завершает свою работу.</span><br /><span>Если же в блоке try вдруг возникает исключение, то обычный порядок выполнения останавливается, и среда CLR начинает искать блок catch, который может обработать данное исключение. Если нужный блок catch найден, то он выполняется, и после его завершения выполняется блок finally.</span><br /><span>Если нужный блок catch не найден, то при возникновении исключения программа аварийно завершает свое выполнение.</span><br /><span>Рассмотрим следующий пример:</span><br /><code><span>int x = 5;</span></code><br /><code><span>int y = x / 0;</span></code><br /><code><span>Console.WriteLine($"Результат: {y}");</span></code><br /><code><span>Console.WriteLine("Конец программы");</span></code><br /><span>В данном случае происходит деление числа на 0, что приведет к генерации исключения. И при запуске приложения в режиме отладки мы увидим в Visual Studio окошко, которое информирует об исключении.</span><br /><span>В этом окошке мы видим, что возникло исключение, которое представляет тип System.DivideByZeroException, то есть попытка деления на ноль. С помощью пункта View Details можно посмотреть более детальную информацию об исключении.</span><br /><span>И в этом случае единственное, что нам остается, это завершить выполнение программы.</span><br /><span>Чтобы избежать подобного аварийного завершения программы, следует использовать для обработки исключений конструкцию try...catch...finally. Так, перепишем пример следующим образом:</span><br /><code><span>try</span></code><br /><code><span>{</span></code><br /><code><span>int x = 5;</span></code><br /><code><span>int y = x / 0;</span></code><br /><code><span>Console.WriteLine($"Результат: {y}"); }</span></code><br /><code><span>catch</span></code><br /><code><span>{ Console.WriteLine("Возникло исключение!"); }</span></code><br /><code><span>finally</span></code><br /><code><span>{ Console.WriteLine("Блок finally"); }</span></code><br /><code><span>Console.WriteLine("Конец программы");</span></code><br /><span>В данном случае у нас опять же возникнет исключение в блоке try, так как мы пытаемся разделить на ноль. И дойдя до строки</span><br /><code><span>int y = x / 0;</span></code><br /><span>выполнение программы остановится. CLR найдет блок catch и передаст управление этому блоку.</span><br /><span>После блока catch будет выполняться блок finally.</span><br /><span>Возникло исключение!</span><br /><span>Блок finally</span><br /><span>Конец программы</span><br /><span>Таким образом, программа по-прежнему не будет выполнять деление на ноль и соответственно не будет выводить результат этого деления, но теперь она не будет аварийно завершаться, а исключение будет обрабатываться в блоке catch.</span><br /><b>Блок catch и фильтры исключений</b><br /><span>Определение блока catch</span><br /><span>За обработку исключения отвечает блок catch, который может иметь следующие формы:</span></p>
            <ul>
              <li><code>catch</code><br /><code>{ // выполняемые инструкции }</code><br />Обрабатывает любое исключение, которое возникло в блоке try. Выше уже был продемонстрирован пример подобного блока.</li>
              <li><code>catch (тип_исключения)</code><br /><code>{ // выполняемые инструкции }</code><br />Обрабатывает только те исключения, которые соответствуют типу, указаному в скобках после оператора catch.</li>
              <li><code>catch (тип_исключения имя_переменной)</code><br /><code>{ // выполняемые инструкции }</code><br />Обрабатывает только те исключения, которые соответствуют типу, указаному в скобках после оператора catch. А вся информация об исключении помещается в переменную данного типа.</li>
            </ul>
            <p><span>Фильтры исключений</span><br /><span>Фильтры исключений позволяют обрабатывать исключения в зависимости от определенных условий. Для их применения после выражения catch идет выражение when, после которого в скобках указывается условие:</span><br /><code><span>catch when(условие)</span><span>{ }</span></code><br /><span>В этом случае обработка исключения в блоке catch производится только в том случае, если условие в выражении when истинно.</span><br /><span>Например:</span><br /><code><span>int x = 1;</span></code><br /><code><span>int y = 0;</span></code><br /><code><span>try</span></code><br /><code><span>{</span></code><br /><code><span>int result1 = x / y;</span></code><br /><code><span>int result2 = y / x;</span></code><br /><code><span>}</span></code><br /><code><span>catch (DivideByZeroException) when (y == 0)</span></code><br /><code><span>{ Console.WriteLine("y не должен быть равен 0"); }</span></code><br /><code><span>catch(DivideByZeroException ex)</span></code><br /><code><span>{ Console.WriteLine(ex.Message); }</span></code><br /><span>В данном случае будет выброшено исключение, так как y=0. Здесь два блока catch, и оба они обрабатывают исключения типа DivideByZeroException, то есть по сути все исключения, генерируемые при делении на ноль. Но поскольку для первого блока указано условие y == 0, то именно этот блок будет обрабатывать данное исключение - условие, указанное после оператора when возвращает true.</span><br /><span>Противоположная ситуация:</span><br /><code><span>int x = 0;</span></code><br /><code><span>int y = 1;</span></code><br /><code><span>try</span></code><br /><code><span>{</span></code><br /><code><span>int result1 = x / y;</span></code><br /><code><span>int result2 = y / x;</span></code><br /><code><span>}</span></code><br /><code><span>catch (DivideByZeroException) when (y == 0)</span></code><br /><code><span>{ Console.WriteLine("y не должен быть равен 0"); }</span></code><br /><code><span>catch(DivideByZeroException ex)</span></code><br /><code><span>{ Console.WriteLine(ex.Message); }</span></code><br /><span>В данном случае будет выброшено исключение, так как x=0. Условие первого блока catch - y == 0 теперь возвращает false. Поэтому CLR будет дальше искать соответствующие блоки catch далее и для обработки исключения выберет второй блок catch. В итоге если мы уберем второй блок catch, то исключение вобще не будет обрабатываться.</span><br /><b>Типы исключений. Класс Exception</b><br /><span>Базовым для всех типов исключений является тип Exception. Этот тип определяет ряд свойств, с помощью которых можно получить информацию об исключении.</span></p>
            <ul>
              <li><code>InnerException</code>: хранит информацию об исключении, которое послужило причиной текущего исключения</li>
              <li><code>Message</code>: хранит сообщение об исключении, текст ошибки</li>
              <li><code>Source</code>: хранит имя объекта или сборки, которое вызвало исключение</li>
              <li><code>StackTrace</code>: возвращает строковое представление стека вызывов, которые привели к возникновению исключения</li>
              <li><code>TargetSite</code>: возвращает метод, в котором и было вызвано исключение</li>
            </ul>
            <p><span>Например, обработаем исключения типа Exception:</span><br /><code><span>try</span></code><br /><code><span>{</span></code><br /><code><span>int x = 5;</span></code><br /><code><span>int y = x / 0;</span></code><br /><code><span>Console.WriteLine($"Результат: {y}");</span></code><br /><code><span>}</span></code><br /><code><span>catch (Exception ex)</span></code><br /><code><span>{</span></code><br /><code><span>Console.WriteLine($"Исключение: {ex.Message}");</span></code><br /><code><span>Console.WriteLine($"Метод: {ex.TargetSite}");</span></code><br /><code><span>Console.WriteLine($"Трассировка стека: {ex.StackTrace}");</span></code><br /><code><span>}</span></code><br /><span>Однако так как тип Exception является базовым типом для всех исключений, то выражение catch (Exception ex) будет обрабатывать все исключения, которые могут возникнуть.</span><br /><span>Но также есть более специализированные типы исключений, которые предназначены для обработки каких-то определенных видов исключений. Их довольно много, я приведу лишь некоторые:</span></p>
            <ul>
              <li><code>DivideByZeroException</code>: представляет исключение, которое генерируется при делении на ноль</li>
              <li><code>ArgumentOutOfRangeException</code>: генерируется, если значение аргумента находится вне диапазона допустимых значений</li>
              <li><code>ArgumentException</code>: генерируется, если в метод для параметра передается некорректное значение</li>
              <li><code>IndexOutOfRangeException</code>: генерируется, если индекс элемента массива или коллекции находится вне диапазона допустимых значений</li>
              <li><code>InvalidCastException</code>: генерируется при попытке произвести недопустимые преобразования типов</li>
              <li><code>NullReferenceException</code>: генерируется при попытке обращения к объекту, который равен null (то есть по сути неопределен)</li>
            </ul>

            <p><b>Создание классов исключений</b><br /><span>Если нас не устраивают встроенные типы исключений, то мы можем создать свои типы. Базовым классом для всех исключений является класс Exception, соответственно для создания своих типов мы можем унаследовать данный класс.</span><br /><span>Допустим, у нас в программе будет ограничение по возрасту:</span><br /><code><span>try</span></code><br /><code><span>{ Person person = new Person { Name = "Tom", Age = 17 }; }</span></code><br /><code><span>catch (Exception ex)</span></code><br /><code><span>{ Console.WriteLine($"Ошибка: {ex.Message}"); }</span></code><br /><code><span>class Person</span></code><br /><code><span>{</span></code><br /><code><span>private int age;</span></code><br /><code><span>public string Name { get; set; } = "";</span></code><br /><code><span>public int Age</span></code><br /><code><span>{</span></code><br /><code><span>get =&gt; age;</span></code><br /><code><span>set</span></code><br /><code><span>{</span></code><br /><code><span>if (value &lt; 18)</span></code><br /><code><span>throw new Exception("Лицам до 18 регистрация запрещена");</span></code><br /><code><span>else</span></code><br /><code><span>age = value;</span></code><br /><code><span>} } }</span></code><br /><span>В классе Person при установке возраста происходит проверка, и если возраст меньше 18, то выбрасывается исключение. Класс Exception принимает в конструкторе в качестве параметра строку, которое затем передается в его свойство Message.</span><br /><span>Но иногда удобнее использовать свои классы исключений. Например, в какой-то ситуации мы хотим обработать определенным образом только те исключения, которые относятся к классу Person. Для этих целей мы можем сделать специальный класс PersonException:</span><br /><code><span>class PersonException : Exception</span></code><br /><code><span>{</span></code><br /><code><span>public PersonException(string message)</span></code><br /><code><span>: base(message) { }</span></code><br /><code><span>}</span></code><br /><span>По сути класс кроме пустого конструктора ничего не имеет, и то в конструкторе мы просто обращаемся к конструктору базового класса Exception, передавая в него строку message. Но теперь мы можем изменить класс Person, чтобы он выбрасывал исключение именно этого типа и соответственно в основной программе обрабатывать это исключение:</span><br /><code><span>try</span></code><br /><code><span>{ Person person = new Person { Name = "Tom", Age = 17 }; }</span></code><br /><code><span>catch (PersonException ex)</span></code><br /><code><span>{ Console.WriteLine($"Ошибка: {ex.Message}"); }</span></code><br /><code><span>class Person</span></code><br /><code><span>{</span></code><br /><code><span>private int age;</span></code><br /><code><span>public string Name { get; set; } = "";</span></code><br /><code><span>public int Age</span></code><br /><code><span>{</span></code><br /><code><span>get =&gt; age;</span></code><br /><code><span>set</span></code><br /><code><span>{</span></code><br /><code><span>if (value &lt; 18)</span></code><br /><code><span>throw new PersonException("Лицам до 18 регистрация запрещена");</span></code><br /><code><span>else</span></code><br /><code><span>age = value; } } }</span></code><br /><span>Однако необязательно наследовать свой класс исключений именно от типа Exception, можно взять какой-нибудь другой производный тип.</span><br /><b>Обработка исключений закончилось</b></p>

          </div>
        </div>
      </div>
    </section>
  </div>
  <nav class="container text-center">
    <router-link @click="scrollToTop()" to="/basicofprogramming"><button type="button" class="btn btn-primary">Основы программирования на C#</button></router-link>
    <router-link @click="scrollToTop()" to="/classstructures"><button type="button" class="btn btn-primary">Классы, структуры и пространства имён</button></router-link>
    <router-link @click="scrollToTop()" to="/objectorientedprogramming"><button type="button" class="btn btn-primary">ООП</button></router-link>
    <router-link @click="scrollToTop()" to="/exceptionhandling"><button type="button" class="btn btn-primary">Обработка исключений</button><br><br></router-link>
    <router-link @click="scrollToTop()" to="/delegate"><button type="button" class="btn btn-primary">Делегаты, события и лямбды</button></router-link>
    <router-link @click="scrollToTop()" to="/interfacee"><button type="button" class="btn btn-primary">Интерфейсы</button></router-link>
    <router-link @click="scrollToTop()" to="/dopioop"><button type="button" class="btn btn-primary">Дополнительны возможности ООП в C#</button><br><br></router-link>
    <router-link @click="scrollToTop()" to="/programmingigr"><button type="button" class="btn btn-primary justify-content-center">Программирование игр</button></router-link>
  </nav>
</template>

<script>
export default {
  name: "exceptionhandling",

  methods: {
    scrollToTop() {
      window.scrollTo(0, 0);
    },
  }
}
</script>

<style scoped>

</style>